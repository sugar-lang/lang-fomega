definition
module Fomega-Lexical

exports
  sorts ID MID QID NAT STRING Keyword PrimitiveType
    BlockComment CommentPart OpenBrace CloseBrace Dash

  lexical syntax
    [\ \t\r\n] -> LAYOUT

    "--" ~[\n]* [\n] -> LAYOUT

    BlockComment -> LAYOUT
    "{-" CommentPart* "-}" -> BlockComment
    ~[\{\-] -> CommentPart
    OpenBrace -> CommentPart
    CloseBrace -> CommentPart
    Dash -> CommentPart
    BlockComment -> CommentPart
    [\-] -> Dash
    [\{] -> OpenBrace
    [\}] -> CloseBrace

  lexical restrictions
    Dash -/- [\}]
    OpenBrace -/- [\-]

  context-free restrictions
    LAYOUT? -/- [\ \t\r\n]

  lexical syntax
    [a-zA-Z][A-Za-z0-9]* -> ID
    [0-9]+ -> NAT
    "\""~[\"\\\n\r]*"\"" -> STRING

    Keyword -> ID {reject}
    PrimitiveType -> ID {reject}

    "forall" -> Keyword
    "mu" -> Keyword
    "if" -> Keyword
    "then" -> Keyword
	"else" -> Keyword
	"case" -> Keyword
	"of" -> Keyword
	"fold" -> Keyword
	"unfold" -> Keyword
    "as" -> Keyword
	"module" -> Keyword
	"import" -> Keyword
	"qualified" -> Keyword
	"public" -> Keyword
    "val" -> Keyword
	"type" -> Keyword
	"true" -> Keyword
	"false" -> Keyword

    "Nat" -> PrimitiveType
    "Bool" -> PrimitiveType
    "String" -> PrimitiveType

  lexical restrictions
    ID -/- [A-Za-z0-9]
    NAT -/- [0-9]

    "if" "then" "else" "case" "of" "fold" "unfold"
    "as" "module" "import" "qualified" "public" 
    "val" "type" "true" "false" -/- [A-Za-z0-9]

    "Nat" "Bool" "String" -/- [A-Za-z0-9]

  lexical syntax
    {ID "."}+ -> MID
	ID "." {ID "."}+ -> QID

  lexical restrictions
    MID -/- [\.]
    QID -/- [\.]

module Fomega-Type
imports Fomega-Lexical

exports
  sorts Type TypeDecl Kind

  context-free syntax
    ID -> Type {cons("TyVar")}
    "Nat" -> Type {cons("TyNat")}
    "Bool" -> Type {cons("TyBool")}
    "String" -> Type {cons("TyString")}
    "{" {TypeDecl ","}* "}" -> Type {cons("TyRecord")}
    "<" {TypeDecl ","}* ">" -> Type {cons("TyVariant")}
	"(" Type ")" -> Type {bracket}

    ID ":" Type -> TypeDecl {cons("TyDecl")}

    "*" -> Kind {cons("KiStar")}
    Kind "=>" Kind -> Kind {cons("KiArrow")}        

    QID -> Type {cons("TyQVar")}

    Type Type -> Type {cons("TyApp"), left}
	Type "**" {Type "**"}+ -> Type {cons("TyTuple"), right}
	Type "->" Type -> Type {cons("TyArrow"), right}
	"forall" ID "::" Kind "." Type -> Type {cons("TyForall")}
	"\\" ID "::" Kind "." Type -> Type {cons("TyAbs")}
	"mu" ID "." Type -> Type {cons("TyMu")}

  context-free priorities
      Type Type -> Type {cons("TyApp"), left}
	> Type "**" {Type "**"}+ -> Type {cons("TyTuple"), right}
	> Type "->" Type -> Type {cons("TyArrow"), right}
	> {
      "forall" ID "::" Kind "." Type -> Type {cons("TyForall")}
	  "\\" ID "::" Kind "." Type -> Type {cons("TyAbs")}
	  "mu" ID "." Type -> Type {cons("TyMu")}
    }

module Fomega-Module
imports Fomega-Lexical
imports Fomega-Type
imports Fomega-Expr

exports
  sorts Module Def Import ModuleDec Public Qualified

  context-free syntax
    "module" MID -> ModuleDec {cons("ModuleDec")}
    ModuleDec Import* Def* -> Module {cons("Module")}
    "import" Qualified? MID -> Import {cons("Import")}
    Public? "val" ID ":" Type "=" Expr -> Def {cons("ValDef")}
    Public? "type" ID "::" Kind "=" Type -> Def {cons("TypeDef")}
 
    "public" -> Public {cons("Public")}
    "qualified" -> Qualified {cons("Qualified")}
    
  context-free start-symbols Module 


module Fomega-Expr
imports Fomega-Lexical
imports Fomega-Type

exports
  sorts Expr Field Branch

  context-free syntax
    ID -> Expr {cons("Var")}
	QID -> Expr {cons("QVar")}
    "(" Expr ")" -> Expr {bracket}
    "{" {Field ","}* "}" -> Expr {cons("Record")}
    "<" Field ">" -> Expr {cons("Variant")}
    "(" Expr "," {Expr ","}+ ")" -> Expr {cons("Tuple")}
    "true" -> Expr {cons("True")}
    "false" -> Expr {cons("False")}
    NAT -> Expr {cons("Nat")}
    STRING -> Expr {cons("String")}

    ID "=" Expr -> Field {cons("Field")}

    "<" ID "=" ID ">" "=>" Expr -> Branch {cons("Branch")}

    Expr "!" ID -> Expr {cons("SelectRcd")}
    Expr "!" NAT -> Expr {cons("SelectTup")}
    Expr Expr -> Expr {cons("App"), left}
    Expr "[" Type "]" -> Expr {cons("TApp")}
    "fold" "[" Type "]" Expr -> Expr {cons("Fold")}
    "unfold" "[" Type "]" Expr -> Expr {cons("Unfold")}
    Expr "as" Type -> Expr {cons("Ascription")}
    "\\" ID ":" Type "." Expr -> Expr {cons("Abs")}
    "\\" ID "::" Kind "." Expr -> Expr {cons("TAbs")}
    "if" Expr "then" Expr "else" Expr -> Expr {cons("Cond")}
    "case" Expr "of" {Branch ";"}+ -> Expr {cons("Case")}

  context-free priorities
    {
      Expr "!" ID -> Expr {cons("SelectRcd")}
      Expr "!" NAT -> Expr {cons("SelectTup")}
    }
    > {
      Expr Expr -> Expr {cons("App"), left}
      Expr "[" Type "]" -> Expr {cons("TApp")}
      "fold" "[" Type "]" Expr -> Expr {cons("Fold")}
      "unfold" "[" Type "]" Expr -> Expr {cons("Unfold")}
    }
    > Expr "as" Type -> Expr {cons("Ascription")}
    > { 
      "\\" ID ":" Type "." Expr -> Expr {cons("Abs")}
      "\\" ID "::" Kind "." Expr -> Expr {cons("TAbs")}
	  "if" Expr "then" Expr "else" Expr -> Expr {cons("Cond")}
      "case" Expr "of" {Branch ";"}+ -> Expr {cons("Case")}
    }

module org/sugarj/languages/Fomega
imports Fomega-Module [
    BlockComment => FomegaBlockComment
    CommentPart => FomegaCommentPart
    OpenBrace => FomegaOpenBrace
    CloseBrace => FomegaCloseBrace
    Dash => FomegaDash
	MID => FomegaMID
    ID => FomegaID
    QID => FomegaQID
    NAT => FomegaNAT
    STRING => FomegaSTRING
    Keyword => FomegaKeyword
    PrimitiveType => FomegaPrimitiveType    
    Type => FomegaType
    TypeDecl => FomegaTypeDecl
    Kind => FomegaKind
    Module => FomegaModule
    Def => FomegaDef
    Import => FomegaImport
    Expr => FomegaExpr
    Field => FomegaField
    ModuleDec => FomegaModuleDec
    Branch => FomegaBranch
    Qualified => FomegaQualified
    Public => FomegaPublic ]
